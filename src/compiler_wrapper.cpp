//--------------------------------------------------------------------------------------------------
// Copyright (c) 2018 Marcus Geelnard
//
// This software is provided 'as-is', without any express or implied warranty. In no event will the
// authors be held liable for any damages arising from the use of this software.
//
// Permission is granted to anyone to use this software for any purpose, including commercial
// applications, and to alter it and redistribute it freely, subject to the following restrictions:
//
//  1. The origin of this software must not be misrepresented; you must not claim that you wrote
//     the original software. If you use this software in a product, an acknowledgment in the
//     product documentation would be appreciated but is not required.
//
//  2. Altered source versions must be plainly marked as such, and must not be misrepresented as
//     being the original software.
//
//  3. This notice may not be removed or altered from any source distribution.
//--------------------------------------------------------------------------------------------------

#include "compiler_wrapper.hpp"

#include "debug_utils.hpp"
#include "hasher.hpp"
#include "sys_utils.hpp"

#include <iostream>
#include <map>

namespace bcache {
compiler_wrapper_t::compiler_wrapper_t(cache_t& cache) : m_cache(cache) {
}

compiler_wrapper_t::~compiler_wrapper_t() {
}

bool compiler_wrapper_t::handle_command(const string_list_t& args, int& return_code) {
  return_code = 1;

  try {
    // Start a hash.
    hasher_t hasher;

    // Hash the preprocessed file contents.
    hasher.update(preprocess_source(args));

    // Hash the (filtered) command line flags.
    hasher.update(filter_arguments(args).join(" ", true));

    // Hash the compiler version string.
    hasher.update(get_compiler_id(args));

    // Finalize the hash.
    const auto hash = hasher.final();

    // Look up the entry in the cache.
    const auto cached_entry = m_cache.lookup(hash);
    if (cached_entry) {
      // Get the list of files that are expected to be generated by the command.
      const auto target_files = get_build_files(args);

      // Copy all files from the cache to their respective target paths.
      // Note: If there is a mismatch in the expected (target) files and the actual (cached) files,
      // this will throw an exception (i.e. fall back to full compilation).
      for (const auto& file : cached_entry.files) {
        const auto& target_file = target_files.at(file.first);
        const auto& source_file = file.second;
        debug::log(debug::INFO) << "Cache hit (" << hash.as_string() << "): " << source_file
                                << " => " << target_file;
        file::link_or_copy(source_file, target_file);
      }

      // Return/print the cached program results.
      std::cout << cached_entry.std_out;
      std::cerr << cached_entry.std_err;
      return_code = cached_entry.return_code;

      return true;
    }

    // Get the list of files that are expected to be generated by the command.
    cache_t::entry_t new_entry;
    new_entry.files = get_build_files(args);

    {
      std::ostringstream ss;
      for (const auto& file : new_entry.files) {
        ss << " " << file::get_file_part(file.second);
      }
      debug::log(debug::INFO) << "Cache miss (" << hash.as_string() << ")" << ss.str();
    }

    // Run the actual compiler command to produce the object file.
    const auto result = sys::run_with_prefix(args, false);

    // Create a new entry in the cache.
    // TODO(m): If we could store stdout, stderr and the return value in the cache, we might want
    // to create cache entries for failed compilations too. Right now we just don't add cache
    // entries for failed compilations.
    if (result.return_code == 0) {
      new_entry.std_out = result.std_out;
      new_entry.std_err = result.std_err;
      new_entry.return_code = result.return_code;
      m_cache.add(hash, new_entry);
    }

    // Everything's ok!
    // Note: Even if the compilation failed, we've done the expected job (running the compiler again
    // would just take twice the time and give the same errors).
    return_code = result.return_code;
    return true;
  } catch (std::exception& e) {
    debug::log(debug::DEBUG) << "Exception: " << e.what();
  } catch (...) {
    // Catch-all in order to not propagate exceptions any higher up (we'll return false).
    debug::log(debug::ERROR) << "UNEXPECTED EXCEPTION";
  }

  return false;
}
}  // namespace bcache
